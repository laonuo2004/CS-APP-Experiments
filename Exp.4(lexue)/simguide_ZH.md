# CS：APP3e Y86-64 处理器模拟器指南

![处理器架构图](images/simguide_1.jpg)

本文档描述了第三版《计算机系统：程序员的视角》第 4 章中 Y86-64 处理器体系结构演示的处理器模拟器。这些模拟器为三种不同的处理器设计建模：SEQ、SEQ+和 PIPE。

## 1 安装

模拟器的代码以名为 `sim.tar` 的 tar 格式文件分发。您可以从 CS:APP3e 网站（csapp.cs.cmu.edu）获取此文件的副本。

使用要安装代码的目录中的 tar 文件，您应该能够执行以下操作：

```bash
linux> tar xf sim.tar
linux> cd sim
linux> make clean
linux> make
```

默认情况下，这会生成模拟器的 GUI（图形用户界面）版本，这需要在系统上安装 Tcl/Tk。如果没有安装，那么您可以选择安装仅 TTY 版本，这个版本在标准输出上以 ASCII 文本显示。有关如何生成 GUI 和 TTY 版本的描述，请参阅文件 `README`。

目录 `sim` 包含以下子目录：

- `misc` 实用程序的源代码文件，例如 YAS（Y86-64 汇编程序）、YIS（Y86-64 指令集模拟器）和 HCL2C（HCL-to-C 转换器）。它还包含 `isa.c` 源文件，所有处理器模拟器都会使用该文件。
- `seq` `seq` 和 `seq+` 模拟器的源代码。包含作业问题 4.52 的 HCL 文件。有关编译不同版本模拟器的说明，请参阅文件 `README`。
- `pipe` `pipe` 模拟器的源代码。包含作业问题 4.54–4.58 的 HCL 文件。有关编译不同版本模拟器的说明，请参阅文件 `README`。
- `y86-code` 本章所示的许多示例程序的 Y86-64 汇编代码。您可以在这些基准程序上自动测试修改后的模拟器。有关如何运行这些测试的说明，请参阅文件 `README`。作为一个运行示例，我们将使用该子目录中的 `asum.ys` 程序。该程序如 CS:APP3e 图 4.7 所示。程序的编译版本如图 1 所示。
- `ptest` 生成不同指令、不同跳转可能性和不同冒险可能性的系统回归测试脚本。这些脚本非常善于发现作业解决方案中的错误。有关如何运行这些测试的说明，请参阅文件 `README`。

```assembly
1                              | # Execution begins at address 0
2  0x000:                      |   .pos 0
3  0x000: 30f40002000000000000 |   irmovq stack, %rsp      # Set up stack pointer
4  0x00a: 803800000000000000   |   call main               # Execute main program
5  0x013: 00                   |   halt                    # Terminate program
6                              | 
7                              | # Array of 4 elements
8  0x018:                      |   .align 8
9  0x018: 0d000d000d000000     | array:  .quad 0x000d000d000d
10 0x020: c000c000c0000000     |         .quad 0x00c000c000c0
11 0x028: 000b000b000b0000     |         .quad 0x0b000b000b00
12 0x030: 00a000a000a00000     |         .quad 0xa000a000a000
13                             | 
14 0x038: 30f71800000000000000 | main:   irmovq array,%rdi
15 0x042: 30f60400000000000000 |         irmovq $4,%rsi
16 0x04c: 805600000000000000   |         call sum            # sum(array, 4)
17 0x055: 90                   |         ret
18                             | 
19                             | # long sum(long *start, long count)
20                             | # start in %rdi, count in %rsi
21 0x056: 30f80800000000000000 | sum:    irmovq $8,%r8       # Constant 8
22 0x060: 30f90100000000000000 |         irmovq $1,%r9       # Constant 1
23 0x06a: 6300                 |         xorq %rax,%rax      # sum = 0
24 0x06c: 6266                 |         andq %rsi,%rsi      # Set CC
25 0x06e: 708700000000000000   |         jmp test            # Goto test
26 0x077: 50a70000000000000000 | loop:   mrmovq (%rdi),%r10  # Get *start
27 0x081: 60a0                 |         addq %r10,%rax      # Add to sum
28 0x083: 6087                 |         addq %r8,%rdi       # start++
29 0x085: 6196                 |         subq %r9,%rsi       # count--. Set CC
30 0x087: 747700000000000000   | test:   jne loop            # Stop when 0 #
31 0x090: 90                   |         ret                 # Return
32                             | 
33                             | # Stack starts here and grows to lower addresses
34 0x200:                      |         .pos 0x200
35 0x200:                      | stack:
```

**图 1：示例目标代码文件。此代码位于 `y86-code` 子目录下的文件 `asum.yo` 中。**

## 2 实用程序

安装完成后，`misc` 目录包含两个有用的程序：

**YAS** Y86-64 汇编程序。这需要一个扩展名为 `.ys` 的 Y86-64 汇编代码文件，并生成一个扩展名为 `.yo` 的文件。生成的文件包含目标代码的 ASCII 版本，如图 1 所示（CS:APP3e 图 4.8 中显示的相同程序的格式略有不同。）调用汇编程序的最简单方法是在 `y86-code` 子目录中使用或创建汇编代码文件。例如，要汇编该目录下的文件 `asum.ys` 程序，我们使用以下命令：

```bash
linux> make asum.yo
```

**YIS** Y86-64 指令模拟器。该程序根据指令集定义执行 Y86-64 机器级程序中的指令。例如，假设您想运行 `y86-code` 子目录内的程序 `asum.yo`，只需运行：

```bash
linux> ../misc/yis asum.yo
```

YIS 模拟程序的执行，然后在终端上打印任何寄存器或内存位置的更改，如 CS:APP3e 第 4.1 节所述。

## 3 处理器模拟器

对于 SEQ、SEQ+和 PIPE 这三个处理器，我们分别提供了模拟器 SSIM、SSIM+和 PSIM。每个模拟器可以在 TTY 或 GUI 模式下运行：

- **TTY 模式** 使用一个极简的、面向终端的界面。终端输出上打印所有内容。调试不是很方便，但可以安装在任何系统上，并且可以用于自动化测试。所有模拟器的默认模式。
- **GUI 模式** 有一个图形用户界面，稍后介绍。对于可视化处理器活动和调试设计的修改版本非常有用。需要在系统上安装 Tcl/Tk。使用 `-g` 命令行选项调用。只能从可执行模拟器程序所在的目录（流水线或顺序程序）才能以 GUI 模式运行。

### 3.1 模拟器命令行选项

对于所有三个模拟器，您可以从命令行指定几个选项：

- `-h` 打印所有命令行选项的摘要。
- `-g` 在 GUI 模式下运行模拟器（默认为 TTY 模式）。
- `-t` （仅 TTY 模式）运行处理器和 ISA 模拟器，比较内存、寄存器文件和条件代码的结果值。如果没有发现差异，它将打印消息“ISA 检查成功”。否则，它将输出有关不同的寄存器文件或内存字的信息。此功能对于测试处理器设计非常有用。
- `-l m` （仅限 TTY 模式）设置指令限制，在停机前最多执行 m 条指令（默认限制为 10000 条指令）。
- `-v n` （仅限 TTY 模式）将详细级别设置为 n，该级别必须介于 0 和 2 之间，默认值为 2。

在 GUI 模式下运行的模拟器必须使用命令行上的目标文件名调用。在 TTY 模式下，目标文件名是可选的，默认来自标准输入。以下是 `seq` 子目录中模拟器的一些典型调用方法：

```bash
linux> ./ssim -h
linux> ./ssim+ -t < ../y86-code/asum.yo
linux> ./ssim -g ../y86-code/asum.yo
```

第一种情况打印 SSIM 的命令行选项摘要。第二种情况以 TTY 模式运行 SSIM+，从标准输入读目标文件 `asum.yo`。寄存器中的结果和内存值与来自高级 ISA 模拟器的值进行比较。第三种情况在 GUI 模式下运行 SSIM，执行 `y86-code` 子目录中目标代码文件 `asum.yo` 中的指令。同样的调用也适用于 `pipe` 子目录中的 PIPE 模拟器 PSIM。

### 3.2 SEQ 模拟器的 GUI 版本

SEQ 处理器模拟器的 GUI 版本从 `seq` 子目录中调用，命令行上指定一个目标代码文件名：

```bash
linux> ./ssim -g ../y86-code/asum.yo &
```

其中，命令行末尾的“&”允许模拟器在后台模式下运行。模拟程序启动并创建三个窗口，如图 2-4 所示。

第一个窗口（图 2）是主控制面板。如果 HCL 文件是由 HCL2C 使用 `-n name` 选项编译的，则主控制窗口的标题将显示为“Y86-64 Processor: name”，否则它将显示为简单的“Y86-64 Processor”。

主控制窗口包含用于控制模拟器的按钮以及有关处理器状态的状态信息。图中标记了窗口的不同部分：

**Control（控制）：** 顶部的按钮控制模拟器。单击 **Quit**（退出）按钮会导致模拟器退出。单击 **Go** 按钮可使模拟器开始运行。单击 **Stop**（停止）按钮可使模拟器暂时停止。单击 **Step**（单步）按钮可使模拟器执行一条指令，然后停止。点击 **Reset**（复位）按钮使模拟器返回其初始状态，此时，程序计数器位于地址 0，寄存器设置为 0，内存除了程序外都清零，条件码设置为 $ZF = 1$，$CF = 0$ 而且 $OF = 0$，程序状态设置为 AOK。按钮下面的滑动条控制模拟器运行时的速度，向右滑动会使模拟器运行的更快。

![SEQ 模拟器的主控制面板](images/simguide_2.jpg)

**图 2：SEQ 模拟器的主控制面板**

![SEQ 模拟器的代码显示窗口](images/simguide_3.jpg)

**图 3：SEQ 模拟器的代码显示窗口**

![SEQ 模拟器的内存显示窗口](images/simguide_4.jpg)

**图 4：SEQ 模拟器的内存显示窗口**

**Stage values（流水线阶段值）：** 此部分显示当前指令评估期间不同处理器信号的值。这些信号几乎与 CS:APP3e 图 4.23 中显示的信号相同。主要区别在于模拟器在标记为 **Instr** 的字段中显示指令的名称，而不是 `icode` 和 `ifun` 的数值。类似地，所有寄存器标识符都使用其名称而不是数字值显示，其中“----”表示不需要访问寄存器。

**Register file（寄存器文件）：** 此部分显示 15 个程序寄存器的值。最近更新的寄存器以浅蓝色突出显示。寄存器内容在第一次设置为非零值后才会显示。请记住，当指令写入程序寄存器时，直到下一个时钟周期开始，寄存器文件才会更新。这意味着您必须再次单步执行模拟器才能看到更新的发生。

**Stat：** 显示当前正在执行的指令的状态。可能的值为：

- **AOK：** 没有遇到问题。
- **ADR：** 试图读取指令或试图读取或写入数据时发生寻址错误。地址不能超过 `0x0FFF`。
- **INS：** 遇到非法指令。
- **HLT：** 遇到停机指令。

**Condition codes（条件码）：** 这些代码显示了三个条件代码的值：ZF、SF 和 OF。

请记住，当指令更改条件码时，直到下一个时钟周期开始，条件码寄存器才会更新。这意味着您必须再次单步执行模拟器才能看到更新的发生。

第一次执行 `asum.yo` 程序的第 29 行时处理器状态如图 2 所示，`asum.yo` 程序如图 1 所示。我们可以看到，程序计数器位于 `0x085`，此时它已处理了指令 `addq %r8, %rdi`，寄存器 `%rax` 保存 `0xd000d000d`，第一个数组元素的总和，而且 `%rsi` 保存 4，即将减少的计数。寄存器 `%rdi` 保存 `0x020`，即第二个数组元素的地址。有一个挂起的 `0x03` 写入寄存器 `%rsi`（因为 `dstE` 设置为 `%rsi`，而 `valE` 设置为 `0x03`）。此写入将在下一个时钟周期开始时进行。

图 3 所示的窗口显示了模拟器正在执行的目标代码文件。编辑框标识正在执行的程序的文件名。您可以在此窗口中编辑文件名，然后单击 **Load**（加载）按钮加载新程序。显示屏的左侧显示正在执行的目标代码，而右侧显示汇编代码文件的文本。中心有一个星号（*），表示当前正在模拟的指令。这对应于图 1 所示 `asum.yo` 程序的第 29 行。

图 4 所示的窗口显示了内存的内容。它只显示自程序开始执行以来更改的最小和最大地址之间的位置。每行显示两个内存字的内容。因此，每行显示 16 个字节的内存，其中字节的地址仅在最低有效十六进制数字上有所不同。内存值的左边是“根”地址，其中最低有效数字显示为“-”。然后，每一列对应于具有最低有效地址数字为 `0x0` 和 `0x8` 的字。图 4 所示的示例具有箭头，指示内存位置 `0x01f0` 和 `0x01f8`。

图中所示的内存内容显示了图 1 所示 `asum.yo` 程序在执行 `sum` 过程期间栈内容。查看到目前为止发生的栈操作，我们看到 `%rsp` 被初始化为 `0x200`（第 3 行）。第 4 行对 `main` 的调用将返回指针 `0x013` 压栈，返回指针被写入地址 `0x01f8`。过程 `main` 调用 `sum`（第 16 行），导致返回指针 `0x055` 被写入地址 `0x01f0`。这说明了内存窗口中显示的所有字，以及栈指针被设置为 `0x01f0` 的原因。

### 3.3 PIPE 模拟器

PIPE 模拟器也生成三个窗口。图 5 显示了控制面板。它具有相同的控件集，以及相同的寄存器文件、状态和条件码显示。中间部分显示流水线寄存器的状态。不同的字段对应于 CS:APP3e 图 4.52 中的字段。该面板底部显示了已模拟的周期数（不包括使流水线流动所需的初始周期）、已完成的指令数以及生成的 CPI。

![PIPE 模拟器的主控制面板](images/simguide_5.jpg)

**图 5：PIPE 模拟器的主控制面板**

![PIPE 模拟器控制面板中单个流水线寄存器的视图](images/simguide_6.jpg)

**图 6：PIPE 模拟器控制面板中单个流水线寄存器的视图**

如图 6 的特写视图所示，每个流水线寄存器都由两部分显示。白色框中的上面值显示流水线寄存器中的当前值。下面的值以灰色背景显示流水线寄存器的输入。这些将在下一个时钟周期加载到寄存器中，除非寄存器插入气泡或暂停。

通过 PIPE 模拟器的数据流与 SEQ 模拟器的数据流动大不相同。使用 SEQ，控制面板显示执行单个指令产生的值。模拟器的每个步骤执行一个完整的指令执行。使用 PIPE，控制面板显示流经流水线的多条指令的值。模拟器的每个步骤对每个指令只执行一个阶段的计算。

图 7 显示了 PIPE 模拟器的代码显示。该格式与 SEQ 的格式类似，不同之处在于，该显示器不是用一个标记来指示正在执行的指令，而是用字符 F、D、E、M 和 W 来指示流水线的每个阶段中有哪些指令，用于取指、译码、执行、内存和写回阶段。

![PIPE 模拟器的代码显示窗口](images/simguide_7.jpg)

**图 7：PIPE 模拟器的代码显示窗口**

PIPE 模拟器也生成一个窗口来显示内存内容。其格式与 SEQ 所示格式相同（图 4）。

图 5 和图 7 所示的示例显示了在图 1 的第 26-30 行中执行循环时流水线的状态。我们可以看到，模拟器已经开始了循环的第一次迭代，通过跳到测试部分（第 30 行）进入了循环。各阶段的状态如下：

**Write back（写回）：** 初始测试的 `jne` 指令（第 30 行）正在完成。

**Memory（内存）：** `mrmovq` 指令（第 26 行）刚刚从地址 `0x018` 读取了 `0x0D000D000D`。我们可以看到地址在流水线寄存器 M 的字段 `valE` 中，以及在 `valM` 输入到流水线寄存器 W 时从内存读取的值。

**Execute（执行）：** 此阶段包含一个气泡。由于 `mrmovq` 指令（第 26 行）和 `addq` 指令（27 行）之间存在加载使用依赖关系，所以插入了气泡。可以看出，这个气泡的作用类似于 `nop` 指令。这解释了为什么图 7 中没有标有“E”的指令。

**Decode（译码）：** `addq` 指令（第 27 行）刚刚从寄存器 `%rax` 读取 `0x0`。它还从寄存器 `%r10` 读取 `0x00D`，但我们可以看到，转发逻辑使用了刚刚从内存读取的值 `0x0D000D000D`（在流水线寄存器 W 中被视为 `valM` 的输入）作为 `valA` 的新值（在流水线寄存器 E 中被看作 `valA` 的输入）。

**Fetch（取指）：** 刚刚从地址 `0x083` 提取了 `addq` 指令（第 28 行）。预计 PC 的新值为 `0x085`。

与每个阶段关联的是其状态字段 **Stat**。此字段显示流水线该阶段中指令的状态。状态 **AOK** 表示未遇到异常。状态值 **BUB** 表示此阶段有气泡，而不是正常指令。其他可能的状态值包括：引用无效内存位置时的 **ADR**，遇到非法指令代码时的 **INS**，流水线中出现问题时的 **PIP**（当某些流水线寄存器的暂停信号和气泡信号都设置为 1 时发生），以及遇到停机指令时的 **HLT**。当最后四种情况中的任何一种达到回写阶段时，模拟器将停止。

如 CS:APP3e 第 4.5.6 节所述，通过流水线携带单个指令的状态以及该指令的其余信息，可以精确处理不同的异常条件。

## 4 一些建议

以下是从我们使用这些模拟器的经验中学到的一些杂项提示。

- 熟悉模拟器操作。尝试运行 `y86-code` 目录中的一些示例程序。对于一些小示例，请确保您了解每条指令是如何处理的。注意有趣的情况，例如预测失误的分支、加载互锁和过程返回。
- 您需要四处寻找信息。看到数据转发的效果尤其棘手。流水线寄存器 E 中信号 `valA` 有七个可能的来源，信号 `valB` 有六个可能的来源。要查看选择了哪一个，需要将这些流水线寄存器字段的输入与可能的来源的值进行比较。可能的来源包括：
    - `R[d_srcA]` 源寄存器由流水线寄存器 E 中 `srcA` 的输入标识。寄存器内容显示在底部。
    - `R[d_srcB]` 源寄存器由流水线寄存器 E 中 `srcB` 的输入标识。寄存器内容显示在底部。
    - `D_valP` 此值是流水线寄存器 D 状态的一部分。
    - `e_valE` 该值位于流水线寄存器 M 中字段 `valE` 的输入端。
    - `M_valE` 此值是流水线寄存器 M 状态的一部分。
    - `m_valM` 此值位于流水线寄存器 W 中字段 `valM` 的输入处。
    - `W_valE` 此值是流水线寄存器 W 状态的一部分。
    - `W_valM` 此值是流水线寄存器 M 状态的一部分。
- 不要覆盖代码。由于数据和代码共享相同的地址空间，程序很容易覆盖某些代码，当它试图执行被覆盖的指令时，会造成完全混乱。将栈设置得离代码足够远以避免这种情况，这一点很重要。
- 避免地址值过大。模拟器不允许任何大于 `0x0FFF` 的地址。此外，如果修改跨越广泛地址范围的内存位置，内存显示将变得不方便。
- 了解 GUI 模式模拟器的一些“功能”（SSIM、SSIM+ 和 PSIM）
    - 您必须从主目录执行程序。换句话说，要运行 SSIM 或 SSIM+，必须位于 `seq` 目录中，而要运行 PSIM，则必须位于 `pipe` 子目录中。这个需求是由于 Tcl 解释器定位模拟器配置文件的方式而产生的。
    - 如果在 Unix 机器上以 GUI 模式运行，请记住初始化 DISPLAY 环境变量：
      `unix> setenv DISPLAY myhost.edu:0`
    - 对于某些 Unix X Window 管理器，“程序代码”窗口以关闭图标开始。如果模拟器启动时没有看到此窗口，则需要通过单击 expand 手动展开。
    - 对于某些 Microsoft Windows X 服务器，当内存内容更改时，“内存内容”窗口不会自动调整大小。在这些情况下，您需要手动调整窗口大小以查看内存内容。
    - 如果您要求模拟器执行一个不是有效 Y86-64 目标文件，模拟器将因段错误而终止。
