# Cache Lab 实验报告

**姓名**: 左逸龙  
**学号**: 1120231863

---

## 一、实验目的

理解 Cache 的工作原理，通过模拟器实现和矩阵转置优化，掌握缓存命中/缺失机制。

---

## 二、Part A：Cache 模拟器

### 实现思路

模拟器核心是一个二维数组表示的 Cache 结构，每个 CacheLine 包含 valid、tag 和 lru 计数器三个字段。

地址解析按标准方式处理：
```c
set_idx = (addr >> b) & ((1 << s) - 1);
tag = addr >> (s + b);
```

LRU 用一个全局计数器实现，每次访问时更新对应行的计数值，替换时找最小的。

对于 M 操作，按规范处理为两次访问（一次 load + 一次 store）。

### 测试结果

跑完 test-csim 全部通过，得分 27/27。

---

## 三、Part B：矩阵转置优化

测试环境的 Cache 是直接映射（E=1），32 组，块大小 32 字节（放 8 个 int）。

### 3.1 32×32

用 8×8 分块。主要问题是对角线上 `A[i][j]` 和 `B[j][i]` 会映射到同一 cache 行产生冲突，所以用 8 个临时变量把 A 的一整行先读出来再写入 B。

结果：288 misses，达到满分线（< 300）。

### 3.2 64×64

这个相对比较麻烦。64×64 矩阵每行 256 字节，cache 总共才 1KB，所以每 4 行就会冲突。直接用 8×8 分块效果很差。

最后的做法是把 8×8 块拆成 4 个 4×4 来处理，先做上半部分，把右上角的数据暂存到 B 的对应位置，然后再调整。具体步骤比较繁琐，但核心思想就是尽量减少 A 和 B 之间的相互驱逐。

结果：1228 misses，满足要求（< 1300）。

### 3.3 61×67

这个反而比较简单。因为 61 和 67 都不是 2 的幂，冲突没那么严重，直接 16×16 分块就够了，注意边界检查即可。

结果：1993 misses（< 2000）。

---

## 四、总结

这个实验让我对 cache 的工作方式有了更直观的认识。之前只是从书上了解概念，做完这个实验才真正体会到 conflict miss 的影响有多大。64×64 的那个卡了挺久，试了好几种分块方式才找到一个能过的。

另外在自己电脑的 WSL 里跑 valgrind 非常慢，差点以为代码有死循环，后来发现只是 valgrind 本身慢而已，把超时时间设大一些就好了。
