## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

1. bitXor函数

**函数要求：**

| 函数名 | bitXor |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | x^y |
| 要求 | 只能使用 ~ 和 & 运算符，将结果返回。 |

**实现分析：**

函数的输入看似很复杂，但是考虑到 `~` 和 `&` 均是在对二进制位进行操作，且函数不涉及进位、移位等操作，因此**各个位本质上是相互独立的**，各种输入均可被归纳为四种位运算的情况：

| x | y | x^y |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

因此我们的核心问题变成了：当两个位相等时，位运算结果为0，否则为1。

由于 `~` 仅能对单个数进行操作，因此表达式的核心在于 `&` 的使用。

让我们先来观察一下四种情况下直接进行 `&` 操作的结果：

| x | y | x&y | ~(x&y) |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

我们可以敏锐地观察到，`~(x&y)` 的结果与 `x^y` 的结果十分相似，只有第一种情况有所不同。如果我们能够尝试构造出一个表达式 $Expr$，使得四种情况的结果分别为 `0111` (与 `1110` 对称)，再让该表达式与 `~(x&y)` 的结果进行 `&` 操作，那么我们不就能得到 `x^y` 的结果了吗？

基于对称的思想，我们可以构造出这一表达式为 `~(~x & ~y)`，于是我们得到了：`x^y = ~(x&y)&~(~x&~y)`。经过检查，操作数为 7，符合要求。

**函数实现：**

```C
int bitXor(int x, int y) {
  return ~(x & y) & ~(~x & ~y);
}
```

2. getByte函数

**函数要求：**

| 函数名 | getByte |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | 从字x中取出第n个字节 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

我将该函数拆解为两个步骤：

1. 将第n个字节移到最低位
2. 取出最低的一个字节

对于第一个步骤，我们可以使用 `>>` 运算符进行移位操作，至于具体需要移动多少位，其结果为 `n * 8`，也就是 `n << 3`。

对于第二个步骤，我们可以将数与 `0xff` 进行 `&` 操作，因为 `0xff` 的二进制表示为 `11111111`，所以与任何数进行 `&` 操作，都会得到该数的最低一个字节。

因此，我们可以得到：`getByte(x, n) = (x >> (n << 3)) & 0xff`。经过检查，操作数为 3，符合要求。

**函数实现：**

```C
int getByte(int x, int n) {
  return (x >> (n << 3)) & 0xff;
}
```

3. logicalShift函数

**函数要求：**

| 函数名 | logicalShift|
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | 逻辑右移 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

C语言当中的 `>>` 运算符是算术右移，并非逻辑右移。

逻辑右移与算术右移的区别在于，逻辑右移会填充0，而算术右移会填充符号位。当首位为0时，逻辑右移与算术右移的结果相同，但当首位为1时，逻辑右移与算术右移的结果不同，例如对于题目当中的例子 `0x87654321`，逻辑右移4位得到 `0x08765432`，而算术右移4位得到 `0xf8765432`。

我们所需要实现的是，无论 `>>` 运算符在前面补的是0还是1，我们都希望将它们变成0。仿照 `getByte` 函数的分析，我们可以通过构造一个动态的掩码 `0...01...1` ，其中 `0...0` 的个数为 `n`，然后再让算数右移后的结果与该掩码进行 `&` 操作，即可得到逻辑右移后的结果。

得到这一掩码的方式有很多种，我采取了比较方便的一种，即先将 `0x01` 左移 `31` 位，得到 `0x80000000`，然后再右移 `n` 位，最后再左移 `1` 位 (即右移 `n-1` 位)，得到 `1...10...0`，其中 `1...1` 的个数为 `n`，最后再按位取反即可。

之所以要先使用 `0x01` 左移 `31` 位得到 `0x80000000`，是因为题目要求不得使用不在 0~255 范围内的常量 (You are not allowed to use big constants such as 0xffffffff.)，因此我们无法直接使用 `0x80000000`。但是考虑到我们的机器使用32位表示 int 类型 (Uses 2s complement, 32-bit representations of integers.)，因此可以通过左移得到更大的常量。

因此最终我们得到的表达式为：`logicalShift(x, n) = (x >> n) & ~(((0x01 << 31) >> n) << 1)`。经过检查，操作数为 6，远小于最大操作数20，符合要求。

**函数实现：**

```C
int logicalShift(int x, int n) {
  return (x >> n) & ~(((0x01 << 31) >> n) << 1);
}
```

4. bitCount函数

**函数要求：**

| 函数名 | bitCount |
|:---:|:---:|
| 参数 | int |
| 功能实现 | 计算x中1的数目 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求统计x中1的数目，一个十分直观的思路是，遍历x的每一位，如果为1，则计数器加1。但是这样会涉及到大量的操作数，因此我们需要找到一种更加高效的方法。

我的思路是借鉴并行计算的思想，将x分为4个字节，然后分别统计每个字节中1的数目，最后将4个字节的结果相加。这样一来，在一次位移操作中，我们可以一次性统计4个位置的1的数目，从而大大提高效率。

最终的函数实现可以参考 `函数实现` 部分。经统计，操作数为 38，小于最大操作数40，符合要求。

**函数实现：**

```C
int bitCount(int x) {
  int bitChecker = 0x01 + (0x01 << 8) + (0x01 << 16) + (0x01 << 24);
  // 0x01010101, ops = 6
  int bitCounter = (x & bitChecker) + ((x >> 1) & bitChecker)
                 + ((x >> 2) & bitChecker) + ((x >> 3) & bitChecker)
                 + ((x >> 4) & bitChecker) + ((x >> 5) & bitChecker)
                 + ((x >> 6) & bitChecker) + ((x >> 7) & bitChecker);
  // 各个字节内部分别统计1的个数， ops = 7 + 8 + 7 = 22
  return (bitCounter & 0xff) + ((bitCounter >> 8) & 0xff)
         + ((bitCounter >> 16) & 0xff) + ((bitCounter >> 24) & 0xff);
  // 将各个字节内的1的个数相加， ops = 3 + 4 + 3 = 10
}
```

5. conditional函数

**函数要求：**

| 函数名 | conditional |
|:---:|:---:|
| 参数 | int , int , int |
| 功能实现 | 类似于C语言中的 x ? y : z |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求实现类似于C语言中的 `x ? y : z` 的功能，也就是当 `x` 为真时，返回 `y`，否则返回 `z`。

我的思路是构造一个路由器 (router)，当 `x` 为真时，将结果路由到 `y`，否则路由到 `z`。为了实现这一点，我们可以仿照掩码的思路，使 `conditional(x, y, z) = (router & y) + (~router & z)`，其中 `router` 满足如下条件：

$$
router = \begin{cases}
0, & \text{if } x = 0 \\
\sim 0, & \text{if } x \neq 0
\end{cases}
$$

如此一来，当 `x` 为真时，`router` 为 `0xfffffff`，`~router` 为 `0`，输入 `z` 会被舍弃，最终结果为 `y`；当 `x` 为假时，则反之。

经过尝试，我们确实可以构造出满足条件的 `router = !x + ~0`，因此最终的函数实现可以参考 `函数实现` 部分。经统计，操作数为 7，小于最大操作数16，符合要求。

**函数实现：**

```C
int conditional(int x, int y, int z) {
  int router = !x + ~0;
  return (router & y) + (~router & z);
}
```

6. tmin函数

**函数要求：**

| 函数名 | tmin |
|:---:|:---:|
| 参数 | void |
| 功能实现 | 返回最小的补码 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求返回最小的补码，在机器使用 32 位表示 int 类型 (Uses 2s complement, 32-bit representations of integers.) 的情况下，最小的补码为 `0x80000000`。

一个十分直接的思路是，将 `0x01` 左移 `31` 位，得到 `0x80000000`。

因此最终我们得到的表达式为：`tmin() = 0x01 << 31`。经过检查，操作数为 1，远小于最大操作数4，符合要求。

**函数实现：**

```C
int tmin(void) {
  return 0x01 << 31;
}
```

7. fitsBits函数

**函数要求：**

| 函数名 | fitsBits |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | x的补码是否可以表示成n位 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求判断x的补码是否可以表示成n位，我们可以反过来理解：判断x的补码是否可以由n位补码扩展而来。因为如果x的补码可以由n位补码扩展而来，那么该32位补码同样可以压缩为同一n位补码来表示。

让我们先来研究一下n位补码数的构成：对于一个n位补码数，其最高位为符号位，其余n-1位为数值位。当我们将其扩展为32位补码数时，采用的扩展方式均为符号扩展，即符号位如果为0，则扩展的位数均填充0，反之为1。如此一来，我们可以得到如下推论：

**推论1：对于任意一个由n位补码数 ($1 \le n \le 32$) 扩展而来的32位补码数，其前 $32-(n-1) = 33-n$ 位全为0或全为1**。

如果一个n位补码数可以扩展为32位补码数，那么这一32位补码数也相应可以被对应的n位补码数表示，这两者之间存在双射关系，不存在一对多或者多对多的情况，因此推论1可以进一步扩展为：

**推论2：如果一个32位补码数可以被n位补码数表示，那么该32位补码数的前 $33-n$ 位全为0或全为1**。

这是因为根据双射关系，该32位补码数压缩得到的n位补码数再扩展为32位补码数后就是该32位补码数本身，结合推论1，我们即可得到推论2。

依据推论2，我们构造 `extended = x >> (n + ~0)`，即x的补码的前 $33-n$ 位，然后判断其是否全为0或全为1即可。

因此最终我们得到的表达式为：`fitsBits(x, n) = (!extended) | (!(~extended))`。经过检查，操作数为 7，小于最大操作数15，符合要求。

**函数实现：**

```C
int fitsBits(int x, int n) {
  int extended = x >> (n + ~0);
  return (!extended) | (!(~extended));
}
```

8. dividePower2函数

**函数要求：**

| 函数名 | dividePower2 |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | 计算x/(2^n) |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求计算x/(2^n)，一个十分直接的思路是将x右移n位，但是题目专门要求向0舍入，这在x为负数时会出现问题，因为一般情况下这种除以2的幂的补码除法是**向下取整**的。

对于这种情况，我们可以添加一个**偏置量**，使得 `x >> n` 的结果比真实结果大一个十分接近但不大于1的数，这样一来，当最终结果向下取整时，`x >> n` 的结果实际上实现了向上取整，同时不会出现结果多1的情况。一般而言，这一偏置量为 `(1 << n) + ~0`，即 $2^n - 1$，这确保最终 `\frac{2^n - 1}{2^n}` 十分接近于1，但小于1。

需要注意的是，这一偏置量仅在x为负数时需要添加，在x为正数时不需要添加。对此，我们可以添加一个掩码，使得偏置量仅在x为负数时生效。掩码的设计十分简单且巧妙，即 `x >> 31`，当x为负数时，结果为 `0xffffffff`，当x为正数时，结果为 `0`。

因此最终我们得到的表达式为：`dividePower2(x, n) = (x + (x >> 31) & ((1 << n) + ~0)) >> n`。经过检查，操作数为 7，小于最大操作数15，符合要求。

**函数实现：**

```C
int dividePower2(int x, int n) {
  return (x + (x >> 31) & ((1 << n) + ~0)) >> n;
}
```

9. negate函数

**函数要求：**

| 函数名 | negate |
|:---:|:---:|
| 参数 | int |
| 功能实现 | 计算-x |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求计算-x，即补码非，可以参照书本P66的旁注部分，这里采取了方法1，即 `-x = ~x + 1`。

如果希望证明这一等式，我们可以对其移项得到以下式子：

$$
x + \sim x + 1 = 0
$$

随后继续移项得到：

$$
\begin{aligned}
x + \sim x = -1 = \mathrm{0xffffffff} \quad (\text{机器使用32位表示int类型}) \\
\end{aligned}
$$

这一式子十分显然，x与~x每个位均相反，相加则得到全1，即`0xffffffff`。因此 `-x = ~x + 1` 这一等式成立。

因此最终我们得到的表达式为：`negate(x) = ~x + 1`。经过检查，操作数为 2，小于最大操作数5，符合要求。

**函数实现：**

```C
int negate(int x) {
  return ~x + 1;
}
```

10. howManyBits函数

**函数要求：**
| 函数名 | howManyBits |
|:---:|:---:|
| 参数 | int |
| 功能实现 | 计算表达x所需的最少位数 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求计算表达x所需的最少位数，核心问题是寻找与符号位不同的最高位所在的位置。

一个十分直接的思路是，从最高位开始，依次向右遍历，直到找到与符号位不同的最高位所在的位置。但是这样做会涉及到大量的操作数，因此我们需要找到一种更加高效的方法。

为了处理方便，我们可以统一先将负数按位取反，这样一来，我们所需要寻找的数就固定为1了。

我的思路是借鉴二分查找的思想，先判断高16位是否有1，如果有，则将x右移16位，继续判断高8位是否有1，以此类推。其计算复杂度为 $\log_2^n$，相较于逐位遍历，效率更高，所需的操作数也更少。

最终函数的实现可以参考 `函数实现` 部分。经统计，操作数为 32，远小于最大操作数90，符合要求。

**函数实现：**

```C
int howManyBits(int x) {
  // 将负数按位取反
  int sign = x >> 31;
  x = x ^ sign;
  
  // 使用二分查找寻找最高位1所在位置
  // 检查高16位是否有1
  int b16 = !!(x >> 16) << 4;
  x = x >> b16;
  
  // 检查高8位是否有1
  int b8 = !!(x >> 8) << 3;
  x = x >> b8;
  
  // 检查高4位是否有1
  int b4 = !!(x >> 4) << 2;
  x = x >> b4;
  
  // 检查高2位是否有1
  int b2 = !!(x >> 2) << 1;
  x = x >> b2;
  
  // 检查最高位是否是1
  int b1 = !!(x >> 1);
  x = x >> b1;
  
  // 检查最低位是否是1
  int b0 = x;
  
  // 总位数 = 找到的位置 + 1（符号位）
  return b16 + b8 + b4 + b2 + b1 + b0 + 1;
}
```

11. isLessOrEqual函数

**函数要求：**

| 函数名 | isLessOrEqual |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | x <= y |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求判断 $x \le y$，我们可以将其转换为判断 $y - x \ge 0$，同时注意到 `-x = ~x + 1`，因此我们可以将其转换为 $y + (-x) \ge 0 \rightarrow y + \sim x + 1 \ge 0$。而如果该式成立，则其补码符号位为0，否则为1。因此，我们可以借助符号位来判断该式是否成立。

但是需要注意的是，当x与y的符号不同时，结果可能会溢出，因此我们需要额外考虑这种情况。幸运的是，当x与y的符号不同时，其大小关系判断起来十分简单，即x为负数，y为正数时，函数返回1，反之返回0。

最终的函数实现可以参考 `函数实现` 部分。经统计，操作数为 16，小于最大操作数24，符合要求。

**函数实现：**

```C
int isLessOrEqual(int x, int y) {
  int sign_x = x >> 31;
  int sign_y = y >> 31;
  int sign_diff = sign_x ^ sign_y;
  int x_negative_y_positive = sign_x & ~sign_y;
  int same_sign_result = ((y + ~x + 1) >> 31) ^ 1;
  return !!(sign_diff & x_negative_y_positive) | (!sign_diff) & same_sign_result;
}
```

12. intLog2函数

**函数要求：**

| 函数名 | intLog2 |
|:---:|:---:|
| 参数 | int |
| 功能实现 | 计算x的以2为底的对数 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**

函数要求计算 $x(x > 0)$ 的以2为底的对数，并且向下取整。本题与 `howManyBits` 这道题高度相似，其本质均是寻找与符号位不同的最高位所在的位置。考虑到本题限制 $x > 0$，因此需要寻找的数固定为1。

最终函数的实现可以参考 `函数实现` 部分，总体上与 `howManyBits` 的实现十分相似，均使用了二分查找的思想。经统计，操作数为 28，远小于最大操作数90，符合要求。

**函数实现：**

```C
int intLog2(int x) {
  int b16 = !!(x >> 16) << 4;
  x = x >> b16;
  int b8 = !!(x >> 8) << 3;
  x = x >> b8;
  int b4 = !!(x >> 4) << 2;
  x = x >> b4;
  int b2 = !!(x >> 2) << 1;
  x = x >> b2;
  int b1 = !!(x >> 1);
  x = x >> b1;
  return b16 + b8 + b4 + b2 + b1;
}
```

13. floatAbsVal函数

**函数要求：**

| 函数名 | floatAbsVal |
|:---:|:---:|
| 参数 | unsigned |
| 功能实现 | 计算f的绝对值的位级表示 |
| 要求 | 只能使用 ! ~ & ^ \| + << >> 运算符，将结果返回。 |

**分析：**



## 四、实验总结

在本段总结实验中遇到的问题或困难，以及对应的解决方法；对实验的建议等。

