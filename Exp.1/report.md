## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

1. bitXor函数

**函数要求：**

| 函数名 | bitXor |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | x^y |
| 要求 | 只能使用 ~ 和 & 运算符，将结果返回。 |

**实现分析：**

函数的输入看似很复杂，但是考虑到 `~` 和 `&` 均是在对二进制位进行操作，且函数不涉及进位、移位等操作，因此**各个位本质上是相互独立的**，各种输入均可被归纳为四种位运算的情况：

| x | y | x^y |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

因此我们的核心问题变成了：当两个位相等时，位运算结果为0，否则为1。

由于 `~` 仅能对单个数进行操作，因此表达式的核心在于 `&` 的使用。

让我们先来观察一下四种情况下直接进行 `&` 操作的结果：

| x | y | x&y | ~(x&y) |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

我们可以敏锐地观察到，`~(x&y)` 的结果与 `x^y` 的结果十分相似，只有第一种情况有所不同。如果我们能够尝试构造出一个表达式 $Expr$，使得四种情况的结果分别为 `0111` (与 `1110` 对称)，再让该表达式与 `~(x&y)` 的结果进行 `&` 操作，那么我们不就能得到 `x^y` 的结果了吗？

基于对称的思想，我们可以构造出这一表达式为 `~(~x & ~y)`，于是我们得到了：`x^y = ~(x&y)&~(~x&~y)`。经过检查，操作数为 7，符合要求。

**函数实现：**

```C
int bitXor(int x, int y) {
  return ~(x & y) & ~(~x & ~y);
}
```

2. getByte函数

**函数要求：**

| 函数名 | getByte |
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | 从字x中取出第n个字节 |
| 要求 | 只能使用 ! ~ & ^ | + << >> 运算符，将结果返回。 |

**分析：**

我将该函数拆解为两个步骤：

1. 将第n个字节移到最低位
2. 取出最低的一个字节

对于第一个步骤，我们可以使用 `>>` 运算符进行移位操作，至于具体需要移动多少位，其结果为 `n * 8`，也就是 `n << 3`。

对于第二个步骤，我们可以将数与 `0xff` 进行 `&` 操作，因为 `0xff` 的二进制表示为 `11111111`，所以与任何数进行 `&` 操作，都会得到该数的最低一个字节。

因此，我们可以得到：`getByte(x, n) = (x >> (n << 3)) & 0xff`。经过检查，操作数为 3，符合要求。

**函数实现：**

```C
int getByte(int x, int n) {
  return (x >> (n << 3)) & 0xff;
}
```

3. logicalShift函数

**函数要求：**

| 函数名 | logicalShift|
|:---:|:---:|
| 参数 | int , int |
| 功能实现 | 逻辑右移 |
| 要求 | 只能使用 ! ~ & ^ | + << >> 运算符，将结果返回。 |

**分析：**

C语言当中的 `>>` 运算符是算术右移，并非逻辑右移。

逻辑右移与算术右移的区别在于，逻辑右移会填充0，而算术右移会填充符号位。当首位为0时，逻辑右移与算术右移的结果相同，但当首位为1时，逻辑右移与算术右移的结果不同，例如对于题目当中的例子 `0x87654321`，逻辑右移4位得到 `0x08765432`，而算术右移4位得到 `0xf8765432`。

我们所需要实现的是，无论 `>>` 运算符在前面补的是0还是1，我们都希望将它们变成0。仿照 `getByte` 函数的分析，我们可以通过构造一个动态的掩码 `0...01...1` ，其中 `0...0` 的个数为 `n`，然后再让算数右移后的结果与该掩码进行 `&` 操作，即可得到逻辑右移后的结果。

得到这一掩码的方式有很多种，我采取了比较方便的一种，即先将 `0x01` 左移 `31` 位，得到 `0x80000000`，然后再右移 `n` 位，最后再左移 `1` 位 (即右移 `n-1` 位)，得到 `1...10...0`，其中 `1...1` 的个数为 `n`，最后再按位取反即可。

之所以要先使用 `0x01` 左移 `31` 位得到 `0x80000000`，是因为题目要求不得使用不在 0~255 范围内的常量 (You are not allowed to use big constants such as 0xffffffff.)，因此我们无法直接使用 `0x80000000`。但是考虑到我们的机器使用32位表示 int 类型 (Uses 2s complement, 32-bit representations of integers.)，因此可以通过左移得到更大的常量。

因此最终我们得到的表达式为：`logicalShift(x, n) = (x >> n) & ~(((0x01 << 31) >> n) << 1)`。经过检查，操作数为 6，远小于最大操作数20，符合要求。

**函数实现：**

```C
int logicalShift(int x, int n) {
  return (x >> n) & ~(((0x01 << 31) >> n) << 1);
}
```

4. bitCount函数

**函数要求：**

| 函数名 | bitCount |
|:---:|:---:|
| 参数 | int |
| 功能实现 | 计算x中1的数目 |
| 要求 | 只能使用 ! ~ & ^ | + << >> 运算符，将结果返回。 |

**分析：**

函数要求统计x中1的数目，一个十分直观的思路是，遍历x的每一位，如果为1，则计数器加1。但是这样会涉及到大量的操作数，因此我们需要找到一种更加高效的方法。

我的思路是借鉴并行计算的思想，将x分为4个字节，然后分别统计每个字节中1的数目，最后将4个字节的结果相加。这样一来，在一次位移操作中，我们可以一次性统计4个位置的1的数目，从而大大提高效率。

最终的函数实现可以参考 `函数实现` 部分。经统计，操作数为 38，小于最大操作数40，符合要求。

**函数实现：**

```C
int bitCount(int x) {
  int bitChecker = 0x01 + (0x01 << 8) + (0x01 << 16) + (0x01 << 24);
  // 0x01010101, ops = 6
  int bitCounter = (x & bitChecker) + ((x >> 1) & bitChecker)
                 + ((x >> 2) & bitChecker) + ((x >> 3) & bitChecker)
                 + ((x >> 4) & bitChecker) + ((x >> 5) & bitChecker)
                 + ((x >> 6) & bitChecker) + ((x >> 7) & bitChecker);
  // 各个字节内部分别统计1的个数， ops = 7 + 8 + 7 = 22
  return (bitCounter & 0xff) + ((bitCounter >> 8) & 0xff)
         + ((bitCounter >> 16) & 0xff) + ((bitCounter >> 24) & 0xff);
  // 将各个字节内的1的个数相加， ops = 3 + 4 + 3 = 10
}
```

## 四、实验总结

在本段总结实验中遇到的问题或困难，以及对应的解决方法；对实验的建议等。

