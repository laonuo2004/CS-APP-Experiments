                            | #/* $begin ncopy-ys */
                            | ##################################################################
                            | # ncopy.ys - Copy a src block of len words to dst.
                            | # Return the number of positive words (>0) contained in src.
                            | #
                            | # 姓名：左逸龙
                            | # 学号：1120231863
                            | #
                            | # ======================== 优化说明 ========================
                            | #
                            | # 【核心思路】
                            | # 本实现结合 pipe-full.hcl 中的"加载转发"优化，使用 10x 循环展开
                            | # 和二叉搜索余数处理，实现了 CPE < 7.5 的性能目标。
                            | #
                            | # 【优化策略】
                            | #
                            | # 1. 加载转发 (Load Forwarding) - 配合 pipe-full.hcl 的修改
                            | #    - 问题：标准 PIPE 中，mrmovq 后紧跟 rmmovq 使用同一寄存器会产生
                            | #      1 个周期的气泡（load-use 冒险）
                            | #    - 解决：在 pipe-full.hcl 中修改 e_valA 信号，当 Execute 阶段的
                            | #      rmmovq 需要的数据正好由 Memory 阶段的 mrmovq 产生时，直接转发
                            | #      m_valM，避免暂停
                            | #    - 效果：每个元素节省 1 个周期
                            | #
                            | # 2. 10x 循环展开 (Loop Unrolling)
                            | #    - 思路：每次循环处理 10 个元素，减少循环控制开销
                            | #    - 展开因子选择：10x 在代码大小（<1000字节）和性能之间取得平衡
                            | #    - 每个元素的处理模式：
                            | #      mrmovq offset(%rdi), %r8  # 从 src 读取
                            | #      rmmovq %r8, offset(%rsi)  # 写入 dst（加载转发消除了气泡）
                            | #      andq %r8, %r8             # 设置条件码
                            | #      jle NextLabel             # 如果 <= 0 跳过计数
                            | #      iaddq $1, %rax            # count++
                            | #
                            | # 3. iaddq 指令
                            | #    - 使用 iaddq 替代 irmovq + addq 组合，减少指令数量
                            | #    - 例如：iaddq $80, %rdi 代替 irmovq $80, %r10 + addq %r10, %rdi
                            | #
                            | # 4. 二叉搜索余数处理
                            | #    - 问题：循环展开后需要处理 0-9 个剩余元素
                            | #    - 思路：使用二叉搜索树减少平均分支次数
                            | #    - 结构：先与 3 比较分为 [0-2], [3], [4-9] 三组
                            | #           再递归细分各子区间
                            | #    - 优势：平均只需 2-3 次比较即可定位到正确的处理入口
                            | #
                            | # 5. 代码大小优化
                            | #    - 用 ret 替代 jmp Done 节省 8 字节（ret=1字节，jmp=9字节）
                            | #    - 余数处理采用 fall-through 结构，从 R9 依次执行到 R1
                            | #
                            | # 【性能结果】
                            | # - 代码大小: 997 字节 (限制: 1000 字节)
                            | # - 平均 CPE: 7.46 (目标: < 7.5)
                            | # - 正确性测试: 68/68 通过
                            | #
                            | ##################################################################
                            | # Do not modify this portion
                            | # Function prologue.
                            | # %rdi = src, %rsi = dst, %rdx = len
0x000:                      | ncopy:
                            | 
                            | ##################################################################
                            | # You can modify this portion
                            | 
                            | 	# ========== 主循环：10x 展开 ==========
                            | 	# 首先将 len 减 10，判断是否能进入主循环
0x000: c0f2f6ffffffffffffff | 	iaddq $-10, %rdx
0x00a: 72d401000000000000   | 	jl Rem			# len < 10，跳转到余数处理
                            | 
0x013:                      | L0:
                            | 	# 处理第 0 个元素
0x013: 50870000000000000000 | 	mrmovq (%rdi), %r8
0x01d: 40860000000000000000 | 	rmmovq %r8, (%rsi)
0x027: 6288                 | 	andq %r8, %r8
0x029: 713c00000000000000   | 	jle L1
0x032: c0f00100000000000000 | 	iaddq $1, %rax
0x03c:                      | L1:
                            | 	# 处理第 1 个元素
0x03c: 50870800000000000000 | 	mrmovq 8(%rdi), %r8
0x046: 40860800000000000000 | 	rmmovq %r8, 8(%rsi)
0x050: 6288                 | 	andq %r8, %r8
0x052: 716500000000000000   | 	jle L2
0x05b: c0f00100000000000000 | 	iaddq $1, %rax
0x065:                      | L2:
                            | 	# 处理第 2 个元素
0x065: 50871000000000000000 | 	mrmovq 16(%rdi), %r8
0x06f: 40861000000000000000 | 	rmmovq %r8, 16(%rsi)
0x079: 6288                 | 	andq %r8, %r8
0x07b: 718e00000000000000   | 	jle L3
0x084: c0f00100000000000000 | 	iaddq $1, %rax
0x08e:                      | L3:
                            | 	# 处理第 3 个元素
0x08e: 50871800000000000000 | 	mrmovq 24(%rdi), %r8
0x098: 40861800000000000000 | 	rmmovq %r8, 24(%rsi)
0x0a2: 6288                 | 	andq %r8, %r8
0x0a4: 71b700000000000000   | 	jle L4
0x0ad: c0f00100000000000000 | 	iaddq $1, %rax
0x0b7:                      | L4:
                            | 	# 处理第 4 个元素
0x0b7: 50872000000000000000 | 	mrmovq 32(%rdi), %r8
0x0c1: 40862000000000000000 | 	rmmovq %r8, 32(%rsi)
0x0cb: 6288                 | 	andq %r8, %r8
0x0cd: 71e000000000000000   | 	jle L5
0x0d6: c0f00100000000000000 | 	iaddq $1, %rax
0x0e0:                      | L5:
                            | 	# 处理第 5 个元素
0x0e0: 50872800000000000000 | 	mrmovq 40(%rdi), %r8
0x0ea: 40862800000000000000 | 	rmmovq %r8, 40(%rsi)
0x0f4: 6288                 | 	andq %r8, %r8
0x0f6: 710901000000000000   | 	jle L6
0x0ff: c0f00100000000000000 | 	iaddq $1, %rax
0x109:                      | L6:
                            | 	# 处理第 6 个元素
0x109: 50873000000000000000 | 	mrmovq 48(%rdi), %r8
0x113: 40863000000000000000 | 	rmmovq %r8, 48(%rsi)
0x11d: 6288                 | 	andq %r8, %r8
0x11f: 713201000000000000   | 	jle L7
0x128: c0f00100000000000000 | 	iaddq $1, %rax
0x132:                      | L7:
                            | 	# 处理第 7 个元素
0x132: 50873800000000000000 | 	mrmovq 56(%rdi), %r8
0x13c: 40863800000000000000 | 	rmmovq %r8, 56(%rsi)
0x146: 6288                 | 	andq %r8, %r8
0x148: 715b01000000000000   | 	jle L8
0x151: c0f00100000000000000 | 	iaddq $1, %rax
0x15b:                      | L8:
                            | 	# 处理第 8 个元素
0x15b: 50874000000000000000 | 	mrmovq 64(%rdi), %r8
0x165: 40864000000000000000 | 	rmmovq %r8, 64(%rsi)
0x16f: 6288                 | 	andq %r8, %r8
0x171: 718401000000000000   | 	jle L9
0x17a: c0f00100000000000000 | 	iaddq $1, %rax
0x184:                      | L9:
                            | 	# 处理第 9 个元素
0x184: 50874800000000000000 | 	mrmovq 72(%rdi), %r8
0x18e: 40864800000000000000 | 	rmmovq %r8, 72(%rsi)
0x198: 6288                 | 	andq %r8, %r8
0x19a: 71ad01000000000000   | 	jle Nxt
0x1a3: c0f00100000000000000 | 	iaddq $1, %rax
0x1ad:                      | Nxt:
                            | 	# 更新指针，准备下一轮迭代
0x1ad: c0f75000000000000000 | 	iaddq $80, %rdi		# src += 10
0x1b7: c0f65000000000000000 | 	iaddq $80, %rsi		# dst += 10
0x1c1: c0f2f6ffffffffffffff | 	iaddq $-10, %rdx	# len -= 10
0x1cb: 751300000000000000   | 	jge L0			# 如果 len >= 0，继续循环
                            | 
                            | 	# ========== 余数处理：二叉搜索 ==========
                            | 	# 此时 rdx 在 [-10, -1]，表示剩余 0-9 个元素
0x1d4:                      | Rem:
0x1d4: c0f20700000000000000 | 	iaddq $7, %rdx		# rdx = len - 3 (因为之前减了10，现在+7相当于原始len-3)
0x1de: 72bf03000000000000   | 	jl R02			# len < 3 → 处理 0-2 个元素
0x1e7: 766c02000000000000   | 	jg R49			# len > 3 → 处理 4-9 个元素
                            | 				# len = 3 → 直接 fall-through 到 R3
                            | 
                            | 	# ---------- 处理 3, 2, 1 个元素（fall-through 结构）----------
0x1f0:                      | R3:
0x1f0: 50871000000000000000 | 	mrmovq 16(%rdi), %r8
0x1fa: 40861000000000000000 | 	rmmovq %r8, 16(%rsi)
0x204: 6288                 | 	andq %r8, %r8
0x206: 711902000000000000   | 	jle R2
0x20f: c0f00100000000000000 | 	iaddq $1, %rax
0x219:                      | R2:
0x219: 50870800000000000000 | 	mrmovq 8(%rdi), %r8
0x223: 40860800000000000000 | 	rmmovq %r8, 8(%rsi)
0x22d: 6288                 | 	andq %r8, %r8
0x22f: 714202000000000000   | 	jle R1
0x238: c0f00100000000000000 | 	iaddq $1, %rax
0x242:                      | R1:
0x242: 50870000000000000000 | 	mrmovq (%rdi), %r8
0x24c: 40860000000000000000 | 	rmmovq %r8, (%rsi)
0x256: 6288                 | 	andq %r8, %r8
0x258: 71e403000000000000   | 	jle Done
0x261: c0f00100000000000000 | 	iaddq $1, %rax
0x26b: 90                   | 	ret			# 直接返回，节省 jmp Done 的 8 字节
                            | 
                            | 	# ---------- 处理 4-9 个元素 ----------
0x26c:                      | R49:
0x26c: c0f2fcffffffffffffff | 	iaddq $-4, %rdx		# rdx = len - 7
0x276: 729a03000000000000   | 	jl R46			# len < 7 → 处理 4-6 个元素
0x27f: 73ed02000000000000   | 	je R7			# len = 7
0x288: c0f2ffffffffffffffff | 	iaddq $-1, %rdx
0x292: 73c402000000000000   | 	je R8			# len = 8
                            | 				# len = 9 → fall-through
                            | 
                            | 	# 9-4 个元素的处理（fall-through 到 R3）
0x29b:                      | R9:
0x29b: 50874000000000000000 | 	mrmovq 64(%rdi), %r8
0x2a5: 40864000000000000000 | 	rmmovq %r8, 64(%rsi)
0x2af: 6288                 | 	andq %r8, %r8
0x2b1: 71c402000000000000   | 	jle R8
0x2ba: c0f00100000000000000 | 	iaddq $1, %rax
0x2c4:                      | R8:
0x2c4: 50873800000000000000 | 	mrmovq 56(%rdi), %r8
0x2ce: 40863800000000000000 | 	rmmovq %r8, 56(%rsi)
0x2d8: 6288                 | 	andq %r8, %r8
0x2da: 71ed02000000000000   | 	jle R7
0x2e3: c0f00100000000000000 | 	iaddq $1, %rax
0x2ed:                      | R7:
0x2ed: 50873000000000000000 | 	mrmovq 48(%rdi), %r8
0x2f7: 40863000000000000000 | 	rmmovq %r8, 48(%rsi)
0x301: 6288                 | 	andq %r8, %r8
0x303: 711603000000000000   | 	jle R6
0x30c: c0f00100000000000000 | 	iaddq $1, %rax
0x316:                      | R6:
0x316: 50872800000000000000 | 	mrmovq 40(%rdi), %r8
0x320: 40862800000000000000 | 	rmmovq %r8, 40(%rsi)
0x32a: 6288                 | 	andq %r8, %r8
0x32c: 713f03000000000000   | 	jle R5
0x335: c0f00100000000000000 | 	iaddq $1, %rax
0x33f:                      | R5:
0x33f: 50872000000000000000 | 	mrmovq 32(%rdi), %r8
0x349: 40862000000000000000 | 	rmmovq %r8, 32(%rsi)
0x353: 6288                 | 	andq %r8, %r8
0x355: 716803000000000000   | 	jle R4
0x35e: c0f00100000000000000 | 	iaddq $1, %rax
0x368:                      | R4:
0x368: 50871800000000000000 | 	mrmovq 24(%rdi), %r8
0x372: 40861800000000000000 | 	rmmovq %r8, 24(%rsi)
0x37c: 6288                 | 	andq %r8, %r8
0x37e: 71f001000000000000   | 	jle R3
0x387: c0f00100000000000000 | 	iaddq $1, %rax
0x391: 70f001000000000000   | 	jmp R3			# 继续处理剩余的 3 个元素
                            | 
                            | 	# ---------- 处理 4-6 个元素的分支入口 ----------
0x39a:                      | R46:
0x39a: c0f20200000000000000 | 	iaddq $2, %rdx		# rdx = len - 5
0x3a4: 726803000000000000   | 	jl R4			# len = 4
0x3ad: 733f03000000000000   | 	je R5			# len = 5
0x3b6: 701603000000000000   | 	jmp R6			# len = 6
                            | 
                            | 	# ---------- 处理 0-2 个元素的分支入口 ----------
0x3bf:                      | R02:
0x3bf: c0f20200000000000000 | 	iaddq $2, %rdx		# rdx = len - 1
0x3c9: 72e403000000000000   | 	jl Done			# len = 0
0x3d2: 734202000000000000   | 	je R1			# len = 1
0x3db: 701902000000000000   | 	jmp R2			# len = 2
                            | 
                            | ##################################################################
                            | # Do not modify the following section of code
                            | # Function epilogue.
0x3e4:                      | Done:
0x3e4: 90                   | 	ret
                            | ##################################################################
                            | # Keep the following label at the end of your function
0x3e5:                      | End:
                            | #/* $end ncopy-ys */
